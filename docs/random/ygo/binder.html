<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Binder View</title>
		<link rel="stylesheet" href="styles.css" />
		<style>
			html {
			background: #191919;
			}
			body {
			background: transparent;
			}
			.binder-container {
			display: flex;
			justify-content: center;
			gap: 40px;
			padding: 40px;
			background-color: #191919;
			}
			.binder-page {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			grid-template-rows: repeat(3, auto);
			gap: 10px;
			background: #111;
			padding: 15px;
			border-radius: 8px;
			border: 2px solid white;
			}
			.binder-page img {
			width: 223px;
			/* Yu-Gi-Oh card width in pixels */
			height: 325px;
			/* Yu-Gi-Oh card height in pixels */
			object-fit: cover;
			/* crop/center if needed */
			cursor: pointer;
			border: 2px solid #555;
			border-radius: 4px;
			transition: transform 0.2s;
			background-color: #000;
			/* optional: avoids flicker before load */
			}
			.binder-page img:hover {
			transform: scale(1.05);
			border-color: gold;
			}
			.nav-button {
			position: fixed;
			top: 50%;
			transform: translateY(-50%);
			width: 50px;
			height: 50px;
			cursor: pointer;
			z-index: 9999;
			background: rgba(0, 0, 0, 0.5);
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			}
			.nav-button img {
			max-width: 70%;
			}
			.prev-button {
			left: 10px;
			}
			.next-button {
			right: 10px;
			}
			.binder-page {
			overflow: hidden;
			/* no scrollbars at all */
			/* or, if you only want to hide vertical scrolling: */
			/* overflow-y: hidden; */
			}
			.sort-controls {
			vertical-align: center;
			align-items: center;    /* vertically center all children */
			gap: 8px;               /* optional: add spacing between items */
			}
		</style>
	</head>
	<body>
		<span class="sort-controls" id="sortControls" style="display:none;">
			<label for="sortBy">Sort by:</label>
			<select id="sortBy"></select>
			| 
			<label for="sortOrder">Order:</label>
			<select id="sortOrder">
				<option value="asc">Ascending</option>
				<option value="desc">Descending</option>
			</select>
			| 
			<div id="sleeveFilterControls" style="text-align:center; margin:10px;">
				<label for="sleeveFilter">Filter by sleeve state:</label>
				<select id="sleeveFilter">
					<option value="">(All)</option>
					<option value="1">Single-sleeved</option>
					<option value="2">Double-sleeved</option>
					<option value="3">(Any sleeve)</option>
					<option value="4">(No sleeves)</option>
				</select>
			</div>
			<input type="text" id="searchInput" placeholder="Search card name...">
<div id="searchResult"></div>

			<button id="resetSortBtn" title="Restore original order">Reset</button>
		</span>
		<span id="sortNotice" style="margin-left:10px; color:#aaa;"></span>
		</div>
		<div class="nav-button prev-button" id="prevPage"><img src="prev.png" alt="Previous"></div>
		<div class="nav-button next-button" id="nextPage"><img src="next.png" alt="Next"></div>
		<div class="binder-container" id="binder">
			<div class="binder-page" id="pageLeft"></div>
			<div class="binder-page" id="pageRight"></div>
		</div>
		<div id="pageControls" style="text-align:center; margin: 20px; background-color: transparent; z-index: 999;">
			<span id="pageIndicator"></span>
			<label for="pageJump" style="margin-left:10px;">Go to page:</label>
			<input type="number" id="pageJump" min="1" style="width:60px;">
			<button id="goToPageBtn">Go</button>
		</div>
		<div id="stats"></div>
		<button id="downloadBlacklistBtn">Download Blacklist</button>
		<button id="downloadSleevesBtn">Download Sleeve States</button>
		<script type="module">
			import { localMode } from './config.js';
			import { manager } from './card.js';
			import { loadCSVAndDisplayCards } from './csv.js';
			import * as common from './common.js';
			import * as sorts from './sort.js';
			
			let currentPageIndex = 0;
			let cardsPerPage = 18;
			let cards = [];
			// Preserve the original order (post-filtering) to allow Reset
			let originalCards = [];
			
			// Configurable options
const singleFirstPage = true;   // show first page as single
const singleLastPage  = true;   // show last page as single

			
			const comparatorMap = new Map(); // key -> { label, fn }
			let currentComparatorKey = '';
			let currentOrder = 'asc';
			
			const sleeves_enabled = true;
			
			async function loadTextFiles() {
				console.log("Loading text files");
			
				// Load blacklist.txt
				try {
					const resBL = await fetch('blacklist.txt');
					if (resBL.ok) {
						const text = await resBL.text();
						blacklist = text.split('\n').map(l => l.trim()).filter(Boolean);
					}
				} catch (err) {
					console.warn('Could not load blacklist.txt', err);
				}
			
				console.log("Blacklist loaded");
			
				// Load sleevestates.txt
				try {
					const resSL = await fetch('sleevestates.txt');
					if (resSL.ok) {
						const json = await resSL.text();
						sleeveStates = JSON.parse(json);
						console.log(sleeveStates);
					}
				} catch (err) {
					console.warn('Could not load sleevestates.txt', err);
				}
			
				console.log("Sleeved states loaded");
			}
			
			function downloadFile(filename, content) {
				const blob = new Blob([content], { type: 'text/plain' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
			}
			
			document.getElementById('downloadBlacklistBtn').addEventListener('click', () => {
				downloadFile('blacklist.txt', blacklist.join('\n'));
			});
			
			document.getElementById('downloadSleevesBtn').addEventListener('click', () => {
				downloadFile('sleevestates.txt', JSON.stringify(sleeveStates, null, 2));
			});
			
			// --- BLACKLIST ---
			let blacklist = [];
			
			// --- SLEEVE STATES ---
			let sleeveStates = {}; // { cardName: 1|2 }
			
			// Utility to set/remove a state and persist
			function setSleeveState(cardName, state) {
				if (state === 0) {
					// Remove entry entirely when un-sleeved
					delete sleeveStates[cardName];
				} else {
					sleeveStates[cardName] = state;
				}
				saveSleeveStates();
			}
			
			// Colors for states
			const outlineColors = {
				1: '2px solid yellow', // single sleeve
				2: '2px solid red' // double sleeve
			};
			
			function getCardsPerPage(pageIndex, totalPages) {
  // First page special case
  if (singleFirstPage && pageIndex === 0) return 9;
  // Last page special case
  if (singleLastPage && pageIndex === totalPages - 1) return 9;
  // Default: two pages (left+right)
  return 18;
}

			
			function renderBinderPage() {
  const leftPage  = document.getElementById('pageLeft');
  const rightPage = document.getElementById('pageRight');
  leftPage.innerHTML = '';
  rightPage.innerHTML = '';

  // --- helpers ---
  function getTotalPages() {
    let base = Math.ceil(cards.length / 18);
    if (singleFirstPage) base++;
    if (singleLastPage) base++;
    return base;
  }

  function getCardsPerPage(pageIndex, totalPages) {
    if (singleFirstPage && pageIndex === 0) return 9;
    if (singleLastPage && pageIndex === totalPages - 2) return 9;
    return 18;
  }

  const totalPages = getTotalPages();
  const cardsThisPage = getCardsPerPage(currentPageIndex, totalPages);

  // offset calculation: each "normal" page = 18 slots, but shift if first page is single
  let offset = currentPageIndex * 18;
  if (singleFirstPage && currentPageIndex > 0) {
    offset -= 9; // first page only consumed 9
  }

  let pageCards = cards.slice(offset, offset + cardsThisPage);

  // pad with placeholders
  while (pageCards.length < cardsThisPage) {
    pageCards.push(null);
  }

  // --- rendering helper for one side ---
  function renderSide(container, sideCards) {
    sideCards.forEach(card => {
      const img = document.createElement('img');
      applyOutlineBasedOnSleeveState(img, card ? card.name : undefined);

      if (card) {
        img.src = card.getImageUrl();
        img.title = card.name;
        img.alt = '';

        // click handler
        img.addEventListener('click', () => common.clickHandler(card, true));

        // context menu → toggle blacklist
        img.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          const idx = blacklist.indexOf(card.name);
          if (idx === -1) {
            blacklist.push(card.name);
            img.style.filter = 'brightness(0)';
          } else {
            blacklist.splice(idx, 1);
            img.style.filter = '';
          }
        });

        // wheel → cycle sleeve states
        if (sleeves_enabled) {
          img.addEventListener('wheel', (e) => {
            e.preventDefault();
            const current = sleeveStates[card.name] || 0;
            const next = (current + 1) % 3;
            if (next === 0) {
              delete sleeveStates[card.name];
              img.style.outline = '';
            } else {
              sleeveStates[card.name] = next;
              img.style.outline = outlineColors[next];
            }
          }, { passive: false });
        }
      } else {
        img.src = 'placeholder.png';
        img.title = '';
        img.alt = '';
      }

      container.appendChild(img);
    });
  }

  // --- single vs double page ---
  if (cardsThisPage === 9) {
    leftPage.style.display = 'none';
    rightPage.style.display = '';
    renderSide(rightPage, pageCards);
  } else {
    leftPage.style.display = '';
    rightPage.style.display = '';
    renderSide(leftPage, pageCards.slice(0, 9));
    renderSide(rightPage, pageCards.slice(9, 18));
  }

  // page indicator
  document.getElementById('pageIndicator').textContent =
    `Page ${currentPageIndex + 1} of ${totalPages}`;
}

			
			document.getElementById('goToPageBtn').addEventListener('click', () => {
				const totalPages = Math.ceil(cards.length / cardsPerPage);
				let pageNum = parseInt(document.getElementById('pageJump').value, 10);
				if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages) {
					currentPageIndex = pageNum - 1;
					renderBinderPage();
				}
			});
			
			function applyOutlineBasedOnSleeveState(img, cardName) {
			
				if (!sleeves_enabled) {
					return;
				}
			
				const state = sleeveStates[cardName] || 0;
				img.style.outline = state > 0 ? outlineColors[state] : '';
			}
			
			// Toggle this to true if you want to remove duplicates by card name
			const filterDuplicates = true;
			
			function stableSortInPlace(arr, cmp) {
				// decorate
				const decorated = arr.map((v, i) => ({ v, i }));
				decorated.sort((a, b) => {
					const r = cmp(a.v, b.v);
					return r !== 0 ? r : a.i - b.i; // stability
				});
				// undecorate
				for (let i = 0; i < arr.length; i++) arr[i] = decorated[i].v;
			}
			
			function normalizeLabel(key) {
				// Create a nice label: "attack" -> "Attack", "ATK" preserved, "rarity" -> "Rarity"
				if (!key) return '';
				const pretty = key.replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
				return pretty.charAt(0).toUpperCase() + pretty.slice(1);
			}
			
			function buildComparatorMap() {
				// 1) Collect from sorts.comparators (object of functions)
				if (sorts && typeof sorts === 'object') {
					if (sorts.comparators && typeof sorts.comparators === 'object') {
						for (const [key, fn] of Object.entries(sorts.comparators)) {
							if (typeof fn === 'function') {
								comparatorMap.set(key, { label: normalizeLabel(key), fn });
							}
						}
					}
					// 2) If sort.js exposes a direct rarity comparator, add it if not present
					if (typeof sorts.rarityComparator === 'function' && !comparatorMap.has('rarity')) {
						comparatorMap.set('rarity', { label: 'Rarity', fn: sorts.rarityComparator });
					}
				}
				// 3) If common.js exposes rarityComparator and we don't have it yet, add it
				if (typeof common.rarityComparator === 'function' && !comparatorMap.has('rarity')) {
					comparatorMap.set('rarity', { label: 'Rarity', fn: common.rarityComparator });
				}
			}
			
			function populateSortUI() {
				const sortControls = document.getElementById('sortControls');
				const sortBy = document.getElementById('sortBy');
				const notice = document.getElementById('sortNotice');
			
				sortBy.innerHTML = '';
			
				if (comparatorMap.size === 0) {
					sortControls.style.display = 'none';
					notice.textContent = 'No comparators detected.';
					return;
				}
			
				// Show controls and fill options
				sortControls.style.display = 'inline-flex';
				notice.textContent = '';
			
				// Default option
				const optDefault = document.createElement('option');
				optDefault.value = '';
				optDefault.textContent = '(Original order)';
				sortBy.appendChild(optDefault);
			
				// Add one option per comparator
				Array.from(comparatorMap.entries())
					.sort((a, b) => a[0].localeCompare(b[0]))
					.forEach(([key, meta]) => {
						const opt = document.createElement('option');
						opt.value = key;
						opt.textContent = meta.label;
						sortBy.appendChild(opt);
					});
			
				// Restore selection if any
				sortBy.value = currentComparatorKey || '';
				document.getElementById('sortOrder').value = currentOrder || 'asc';
			}
			
			function applySort() {
				const sortBy = document.getElementById('sortBy').value;
				const order = document.getElementById('sortOrder').value;
			
				currentComparatorKey = sortBy;
				currentOrder = order;
			
				if (!sortBy) {
					// Reset to original order
					cards = originalCards.slice();
				} else {
					const meta = comparatorMap.get(sortBy);
					if (!meta) return;
					const baseCmp = meta.fn;
					const cmp = (a, b) => {
						const r = baseCmp(a, b);
						// Ensure numeric sort contract and invert for desc
						return order === 'desc' ? -r : r;
					};
					cards = originalCards.slice(); // sort from original baseline each time
					stableSortInPlace(cards, cmp);
				}
				currentPageIndex = 0;
				renderBinderPage();
			}
			
			document.getElementById('sortBy').addEventListener('change', applySort);
			document.getElementById('sortOrder').addEventListener('change', applySort);
			document.getElementById('resetSortBtn').addEventListener('click', () => {
				document.getElementById('sortBy').value = '';
				document.getElementById('sortOrder').value = 'asc';
				currentComparatorKey = '';
				currentOrder = 'asc';
				cards = originalCards.slice();
				currentPageIndex = 0;
				renderBinderPage();
			});
			
			async function initBinder(csvFile) {
				if (!localMode) {
					return;
				}
			
				await loadTextFiles();
			
				const res = await fetch(csvFile)
					.then(res => {
						if (!res.ok) {
							throw new Error(`Failed to load CSV: ${res.status} ${res.statusText}`);
						}
						return res.text();
					})
					.then(csvText => {
						if (!csvText.trim()) {
							throw new Error("CSV file is empty or unreadable.");
						}
			
						manager.loadCards(csvText);
			
						let filtered = manager.cards.filter(card => !blacklist.includes(card.name));
			
						// Step 1: Remove any 'Product' type cards (case-insensitive)
						filtered = filtered.filter(
							card => !card.type.toLowerCase().includes("product") && !card.rarity.toLowerCase().includes("fake")
						);
			
						// Step 2: Optionally remove duplicates (same card.name)
						if (filterDuplicates) {
							const seenNames = new Set();
							filtered = filtered.filter(card => {
								if (seenNames.has(card.name)) {
									return false;
								}
								seenNames.add(card.name);
								return true;
							});
						}
			
						// After filtering and before originalCards assignment in initBinder
						filtered.forEach(card => {
							sorts.precomputeNumericFields(card);
						});
			
						const sleeveFilter = document.getElementById('sleeveFilter').value;
						if (sleeveFilter === "1" || sleeveFilter === "2") {
							filtered = filtered.filter(card => (sleeveStates[card.name] || 0) === parseInt(sleeveFilter));
						} else if (sleeveFilter === "3") {
							// Keep only cards that have *any* sleeve (1 or 2)
							filtered = filtered.filter(card => {
								const state = sleeveStates[card.name] || 0;
								return state === 1 || state === 2;
							});
						} else if (sleeveFilter === "4") {
						filtered = filtered.filter(card => {
								const state = sleeveStates[card.name] || 0;
								return state === 0;
							});
						}
			
						// Set working and original arrays
						originalCards = filtered.slice();
						cards = filtered.slice();
			
			
						// Build comparators and UI
						buildComparatorMap();
						populateSortUI();
			
						renderBinderPage();
						updateStats();
					})
					.catch(err => {
						console.error("Error loading binder data:", err);
						// Optional: show a message in the UI
						const binderContainer = document.getElementById('binder');
						if (binderContainer) {
							binderContainer.innerHTML = `<p style="color:white; text-align:center;">Unable to load binder data.<br>${err.message}</p>`;
						}
					});
			}
			
			function updateStats() {
				const totalCards = cards.length;
				const totalBlacklisted = blacklist.length;
				let unsleeved = 0,
					single = 0,
					double = 0;
				cards.forEach(c => {
					const state = sleeveStates[c.name] || 0;
					if (state === 0) unsleeved++;
					if (state === 1) single++;
					if (state === 2) double++;
				});
				document.getElementById('stats').textContent =
					`Total: ${totalCards} | Blacklisted: ${totalBlacklisted} | Unsleeved: ${unsleeved} | Single: ${single} | Double: ${double}`;
			}
			
			function findCardPosition(cardName) {
  const idx = cards.findIndex(c => c && c.name.toLowerCase().includes(cardName.toLowerCase()));
  if (idx === -1) return null;

  // compute page/slot
  let pageIndex = Math.floor(idx / 18);
  let slot = (idx % 18) + 1;

  // adjust if singleFirstPage
  if (singleFirstPage) {
    if (idx < 9) {
      // it’s on the single first page
      pageIndex = 0;
      slot = (idx % 9) + 1;
    } else {
      // shift page index forward by 1
      pageIndex = Math.floor((idx - 9) / 18) + 1;
      slot = ((idx - 9) % 18) + 1;
    }
  }

  // adjust if singleLastPage
  const totalPages = (function() {
    let base = Math.ceil(cards.length / 18);
    if (singleFirstPage) base++;
    if (singleLastPage) base++;
    return base;
  })();

  // If it’s in the last 9 cards and singleLastPage is enabled
  if (singleLastPage) {
    const lastPageStart = cards.length - 9;
    if (idx >= lastPageStart) {
      pageIndex = totalPages - 1;
      slot = (idx - lastPageStart) + 1;
    }
  }

  const card = cards[idx];
  const sleeveState = sleeveStates[card.name] || 0; // 0 = none, 1/2 = your custom states

  return {
    page: pageIndex + 1,   // human-readable page number
    slot: slot,            // 1–9
    name: card.name,       // card name
    sleeve: sleeveState    // current sleeve state
  };
}

document.getElementById('searchInput').addEventListener('change', (e) => {
  const query = e.target.value.trim();
  const result = findCardPosition(query);
  const output = document.getElementById('searchResult');
  if (result) {
    output.textContent = `${result.name} is on page ${result.page}, slot ${result.slot}, sleeve state ${result.sleeve}`;
  } else {
    output.textContent = `${query} not found`;
  }
});

			
			
			document.getElementById('prevPage').addEventListener('click', () => {
				if (currentPageIndex > 0) {
					currentPageIndex--;
					renderBinderPage();
				}
			});
			
			document.getElementById('nextPage').addEventListener('click', () => {
				if ((currentPageIndex + 1) * cardsPerPage < cards.length) {
					currentPageIndex++;
					renderBinderPage();
				}
			});
			
			// Read ?file=... from URL
			const params = new URLSearchParams(window.location.search);
			const csvFileParam = params.get("file");
			
			// Fallback if no param provided
			const csvFile = csvFileParam ? decodeURIComponent(csvFileParam) : 'cards.csv';
			
			// Then use it
			initBinder(csvFile);
			
			document.querySelectorAll('.binder-page').forEach(page => {
				page.addEventListener('wheel', e => {
					e.preventDefault();
				}, { passive: false });
			});
			
			document.getElementById('sleeveFilter').addEventListener('change', () => {
				initBinder(csvFile);
			});
			
		</script>
	</body>
</html>
